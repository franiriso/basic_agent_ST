/*
 * Academic License - for use in teaching, academic research, and meeting
 * course requirements at degree granting institutions only.  Not for
 * government, commercial, or other organizational use.
 *
 * primitives.c
 *
 * Code generation for function 'primitives'
 *
 */

/* Include files */
#include "primitives.h"
#include "rt_nonfinite.h"
#include "rt_nonfinite.h"
#include <math.h>

/* Function Declarations */
static double rt_powd_snf(double u0, double u1);

/* Function Definitions */
static double rt_powd_snf(double u0, double u1)
{
  double y;
  if (rtIsNaN(u0) || rtIsNaN(u1)) {
    y = rtNaN;
  } else {
    double d;
    double d1;
    d = fabs(u0);
    d1 = fabs(u1);
    if (rtIsInf(u1)) {
      if (d == 1.0) {
        y = 1.0;
      } else if (d > 1.0) {
        if (u1 > 0.0) {
          y = rtInf;
        } else {
          y = 0.0;
        }
      } else if (u1 > 0.0) {
        y = 0.0;
      } else {
        y = rtInf;
      }
    } else if (d1 == 0.0) {
      y = 1.0;
    } else if (d1 == 1.0) {
      if (u1 > 0.0) {
        y = u0;
      } else {
        y = 1.0 / u0;
      }
    } else if (u1 == 2.0) {
      y = u0 * u0;
    } else if ((u1 == 0.5) && (u0 >= 0.0)) {
      y = sqrt(u0);
    } else if ((u0 < 0.0) && (u1 > floor(u1))) {
      y = rtNaN;
    } else {
      y = pow(u0, u1);
    }
  }
  return y;
}

double a_opt(double t, double v0, double a0, double sf, double vf, double af,
             double T)
{
  double b_out1_tmp;
  double out1_tmp;
  double t2;
  double t3;
  double t4;
  double t4_tmp;
  /* A_OPT */
  /*     OUT1 = A_OPT(t,V0,A0,SF,VF,AF,T) */
  /*     This function was generated by the Symbolic Math Toolbox version 24.1.
   */
  /*     02-Dec-2025 13:33:10 */
  t2 = T * T;
  t3 = af * t2;
  t4_tmp = a0 * t2;
  t4 = t4_tmp * 3.0;
  out1_tmp = T * v0;
  b_out1_tmp = T * vf;
  return ((a0 - 1.0 / rt_powd_snf(T, 5.0) * rt_powd_snf(t, 3.0) *
                    ((((sf * -12.0 - t3) + out1_tmp * 6.0) + b_out1_tmp * 6.0) +
                     t4_tmp) *
                    10.0) +
          t * t / (t2 * t2) *
              ((((sf * -30.0 - t3 * 2.0) + t4) + out1_tmp * 16.0) +
               b_out1_tmp * 14.0) *
              6.0) -
         1.0 / rt_powd_snf(T, 3.0) * t *
             ((((sf * -20.0 + t4) - t3) + out1_tmp * 12.0) + b_out1_tmp * 8.0) *
             3.0;
}

void coef_list(double v0, double a0, double sf, double vf, double af, double T,
               double coef_list_var[6])
{
  double b_coef_list_var_tmp;
  double coef_list_var_tmp;
  double t2;
  double t3;
  double t4;
  double t4_tmp;
  /* COEF_LIST */
  /*     COEF_LIST_VAR = COEF_LIST(V0,A0,SF,VF,AF,T) */
  /*     This function was generated by the Symbolic Math Toolbox version 24.1.
   */
  /*     02-Dec-2025 13:33:11 */
  t2 = T * T;
  t3 = af * t2;
  t4_tmp = a0 * t2;
  t4 = t4_tmp * 3.0;
  coef_list_var[0] = 0.0;
  coef_list_var[1] = v0;
  coef_list_var[2] = a0;
  coef_list_var_tmp = T * v0;
  b_coef_list_var_tmp = T * vf;
  coef_list_var[3] = 1.0 / rt_powd_snf(T, 3.0) *
                     ((((sf * -20.0 + t4) - t3) + coef_list_var_tmp * 12.0) +
                      b_coef_list_var_tmp * 8.0) *
                     -3.0;
  coef_list_var[4] =
      1.0 / (t2 * t2) *
      ((((sf * -30.0 - t3 * 2.0) + t4) + coef_list_var_tmp * 16.0) +
       b_coef_list_var_tmp * 14.0) *
      12.0;
  coef_list_var[5] = 1.0 / rt_powd_snf(T, 5.0) *
                     ((((sf * -12.0 - t3) + coef_list_var_tmp * 6.0) +
                       b_coef_list_var_tmp * 6.0) +
                      t4_tmp) *
                     -60.0;
}

double coeffs_a_opt(double t, const double in2[6])
{
  /* COEFFS_A_OPT */
  /*     COEFFS_A_OPT = COEFFS_A_OPT(T,IN2) */
  /*     This function was generated by the Symbolic Math Toolbox version 24.1.
   */
  /*     02-Dec-2025 13:33:10 */
  return ((in2[2] + in2[3] * t) + in2[4] * (t * t) / 2.0) +
         in2[5] * rt_powd_snf(t, 3.0) / 6.0;
}

double coeffs_v_opt(double t, const double in2[6])
{
  /* COEFFS_V_OPT */
  /*     COEFFS_V_OPT = COEFFS_V_OPT(T,IN2) */
  /*     This function was generated by the Symbolic Math Toolbox version 24.1.
   */
  /*     02-Dec-2025 13:33:10 */
  return (((in2[1] + in2[2] * t) + in2[3] * (t * t) / 2.0) +
          in2[4] * rt_powd_snf(t, 3.0) / 6.0) +
         in2[5] * rt_powd_snf(t, 4.0) / 24.0;
}

double final_opt_pos_j0(double v0, double a0, double b_j0, double vf, double af,
                        double T)
{
  double final_opt_pos_j0_var_tmp;
  double t2;
  /* FINAL_OPT_POS_J0 */
  /*     FINAL_OPT_POS_J0_VAR = FINAL_OPT_POS_J0(V0,A0,J0,VF,AF,T) */
  /*     This function was generated by the Symbolic Math Toolbox version 24.1.
   */
  /*     02-Dec-2025 13:33:19 */
  t2 = T * T;
  final_opt_pos_j0_var_tmp = rt_powd_snf(T, 3.0);
  return final_opt_pos_j0_var_tmp *
         (b_j0 +
          1.0 / final_opt_pos_j0_var_tmp *
              (((T * v0 * 12.0 + T * vf * 8.0) + a0 * t2 * 3.0) - af * t2) *
              3.0) /
         60.0;
}

void final_opt_time_j0_pass(double v0, double a0, double sf,
                            double final_opt_time_j0_pass_var[2])
{
  double t2;
  double t9;
  /* FINAL_OPT_TIME_J0_PASS */
  /*     FINAL_OPT_TIME_J0_PASS_VAR = FINAL_OPT_TIME_J0_PASS(V0,A0,SF) */
  /*     This function was generated by the Symbolic Math Toolbox version 24.1.
   */
  /*     02-Dec-2025 13:24:34 */
  t2 = v0 * 5.0;
  t9 = 2.23606797749979 * sqrt(a0 * sf * 8.0 + t2 * v0);
  final_opt_time_j0_pass_var[0] = sf * 10.0 / (t2 + t9);
  final_opt_time_j0_pass_var[1] = sf * 10.0 / (t2 - t9);
}

double final_opt_time_stop(double v0, double a0, double sf)
{
  /* FINAL_OPT_TIME_STOP */
  /*     OUT1 = FINAL_OPT_TIME_STOP(V0,A0,SF) */
  /*     This function was generated by the Symbolic Math Toolbox version 24.1.
   */
  /*     02-Dec-2025 13:33:16 */
  return sf * 10.0 / (v0 * 2.0 + sqrt(a0 * sf * 5.0 + v0 * v0 * 4.0));
}

double final_opt_vel_j0_pass(double v0, double a0, double b_j0, double af,
                             double sf, double T)
{
  double t2;
  /* FINAL_OPT_VEL_J0_PASS */
  /*     FINAL_OPT_VEL_J0_PASS_VAR = FINAL_OPT_VEL_J0_PASS(V0,A0,J0,AF,SF,T) */
  /*     This function was generated by the Symbolic Math Toolbox version 24.1.
   */
  /*     02-Dec-2025 13:24:33 */
  t2 = T * T;
  return ((((sf * -60.0 + T * v0 * 36.0) + a0 * t2 * 9.0) - af * t2 * 3.0) +
          rt_powd_snf(T, 3.0) * b_j0) *
         -0.041666666666666664 / T;
}

double j_opt(double t, double v0, double a0, double sf, double vf, double af,
             double T)
{
  double b_out1_tmp;
  double out1_tmp;
  double t2;
  double t3;
  double t4;
  double t4_tmp;
  /* J_OPT */
  /*     OUT1 = J_OPT(t,V0,A0,SF,VF,AF,T) */
  /*     This function was generated by the Symbolic Math Toolbox version 24.1.
   */
  /*     02-Dec-2025 13:33:10 */
  t2 = T * T;
  t3 = af * t2;
  t4_tmp = a0 * t2;
  t4 = t4_tmp * 3.0;
  out1_tmp = T * v0;
  b_out1_tmp = T * vf;
  return (1.0 / rt_powd_snf(T, 3.0) *
              ((((sf * -20.0 + t4) - t3) + out1_tmp * 12.0) +
               b_out1_tmp * 8.0) *
              -3.0 -
          1.0 / rt_powd_snf(T, 5.0) * (t * t) *
              ((((sf * -12.0 - t3) + out1_tmp * 6.0) + b_out1_tmp * 6.0) +
               t4_tmp) *
              30.0) +
         t / (t2 * t2) *
             ((((sf * -30.0 - t3 * 2.0) + t4) + out1_tmp * 16.0) +
              b_out1_tmp * 14.0) *
             12.0;
}

void primitives_initialize(void)
{
}

void primitives_terminate(void)
{
}

double s_opt(double t, double v0, double a0, double sf, double vf, double af,
             double T)
{
  double b_out1_tmp;
  double out1_tmp;
  double t2;
  double t3;
  double t4;
  double t4_tmp;
  /* S_OPT */
  /*     OUT1 = S_OPT(t,V0,A0,SF,VF,AF,T) */
  /*     This function was generated by the Symbolic Math Toolbox version 24.1.
   */
  /*     02-Dec-2025 13:33:10 */
  t2 = T * T;
  t3 = af * t2;
  t4_tmp = a0 * t2;
  t4 = t4_tmp * 3.0;
  out1_tmp = T * v0;
  b_out1_tmp = T * vf;
  return (((t * v0 + a0 * (t * t) / 2.0) -
           1.0 / rt_powd_snf(T, 5.0) * rt_powd_snf(t, 5.0) *
               ((((sf * -12.0 - t3) + out1_tmp * 6.0) + b_out1_tmp * 6.0) +
                t4_tmp) /
               2.0) -
          1.0 / rt_powd_snf(T, 3.0) * rt_powd_snf(t, 3.0) *
              ((((sf * -20.0 + t4) - t3) + out1_tmp * 12.0) +
               b_out1_tmp * 8.0) /
              2.0) +
         rt_powd_snf(t, 4.0) / (t2 * t2) *
             ((((sf * -30.0 - t3 * 2.0) + t4) + out1_tmp * 16.0) +
              b_out1_tmp * 14.0) /
             2.0;
}

void student_pass_primitive(double v0, double a0, double sf, double vfmin,
                            double vfmax, double Tmin, double Tmax,
                            double coeffsT2[6], double *v2, double *T2,
                            double coeffsT1[6], double *v1, double *T1)
{
  int i;
  /*  */
  /*            Agent Logic */
  /*          Pass Primitive */
  /*               2025 */
  /*  */
  if (a0 >= 0.0) {
    double vstar;
    double vstar_tmp;
    /* FINAL_OPT_TIME_PASS */
    /*     OUT1 = FINAL_OPT_TIME_PASS(V0,A0,SF,VF) */
    /*     This function was generated by the Symbolic Math Toolbox
     * version 24.1. */
    /*     02-Dec-2025 13:24:29 */
    vstar = a0 * sf * 60.0;
    vstar_tmp = v0 * v0 * 49.0;
    *T2 = sf * 30.0 /
          ((v0 * 7.0 + vfmin * 8.0) +
           sqrt(((vstar + v0 * vfmin * 112.0) + vstar_tmp) +
                vfmin * vfmin * 64.0));
    /* FINAL_OPT_TIME_PASS */
    /*     OUT1 = FINAL_OPT_TIME_PASS(V0,A0,SF,VF) */
    /*     This function was generated by the Symbolic Math Toolbox
     * version 24.1. */
    /*     02-Dec-2025 13:24:29 */
    *T1 = sf * 30.0 /
          ((v0 * 7.0 + vfmax * 8.0) +
           sqrt(((vstar + v0 * vfmax * 112.0) + vstar_tmp) +
                vfmax * vfmax * 64.0));
  } else {
    double vstar;
    double vstar_tmp;
    vstar_tmp = a0 * sf;
    vstar = 0.25 * (sqrt(15.0 - vstar_tmp) - 7.0 * v0);
    if ((vstar < vfmin) && (vfmin < vfmax)) {
      /* FINAL_OPT_TIME_PASS */
      /*     OUT1 = FINAL_OPT_TIME_PASS(V0,A0,SF,VF) */
      /*     This function was generated by the Symbolic Math Toolbox
       * version 24.1. */
      /*     02-Dec-2025 13:24:29 */
      vstar = vstar_tmp * 60.0;
      vstar_tmp = v0 * v0 * 49.0;
      *T2 = sf * 30.0 /
            ((v0 * 7.0 + vfmin * 8.0) +
             sqrt(((vstar + v0 * vfmin * 112.0) + vstar_tmp) +
                  vfmin * vfmin * 64.0));
      /* FINAL_OPT_TIME_PASS */
      /*     OUT1 = FINAL_OPT_TIME_PASS(V0,A0,SF,VF) */
      /*     This function was generated by the Symbolic Math Toolbox
       * version 24.1. */
      /*     02-Dec-2025 13:24:29 */
      *T1 = sf * 30.0 /
            ((v0 * 7.0 + vfmax * 8.0) +
             sqrt(((vstar + v0 * vfmax * 112.0) + vstar_tmp) +
                  vfmax * vfmax * 64.0));
    } else if ((vfmin < vstar) && (vstar < vfmax)) {
      *T2 = sqrt(15.0 * sf / -a0);
      /* FINAL_OPT_TIME_PASS */
      /*     OUT1 = FINAL_OPT_TIME_PASS(V0,A0,SF,VF) */
      /*     This function was generated by the Symbolic Math Toolbox
       * version 24.1. */
      /*     02-Dec-2025 13:24:29 */
      *T1 = sf * 30.0 /
            ((v0 * 7.0 + vfmax * 8.0) +
             sqrt(((vstar_tmp * 60.0 + v0 * vfmax * 112.0) + v0 * v0 * 49.0) +
                  vfmax * vfmax * 64.0));
    } else {
      *T2 = 0.0;
      *T1 = 0.0;
    }
  }
  if ((!(Tmin == 0.0)) || (!(Tmax == 0.0))) {
    *T1 = fmax(*T1, Tmin);
    *T2 = fmin(*T2, Tmax);
  }
  if ((*T1 > 0.0) && (*T1 <= *T2)) {
    /* FINAL_OPT_VEL_PASS */
    /*     FINAL_OPT_VEL_PASS_VAR = FINAL_OPT_VEL_PASS(V0,A0,SF,T) */
    /*     This function was generated by the Symbolic Math Toolbox
     * version 24.1. */
    /*     02-Dec-2025 13:24:28 */
    *v1 = ((sf * -15.0 + *T2 * v0 * 7.0) + *T2 * *T2 * a0) * -0.125 / *T2;
    /* FINAL_OPT_VEL_PASS */
    /*     FINAL_OPT_VEL_PASS_VAR = FINAL_OPT_VEL_PASS(V0,A0,SF,T) */
    /*     This function was generated by the Symbolic Math Toolbox
     * version 24.1. */
    /*     02-Dec-2025 13:24:28 */
    *v2 = ((sf * -15.0 + *T1 * v0 * 7.0) + *T1 * *T1 * a0) * -0.125 / *T1;
    coef_list(v0, a0, sf, *v2, 0.0, *T1, coeffsT1);
    coef_list(v0, a0, sf, *v1, 0.0, *T2, coeffsT2);
  } else {
    for (i = 0; i < 6; i++) {
      coeffsT1[i] = 0.0;
      coeffsT2[i] = 0.0;
    }
    *T1 = 0.0;
    *T2 = 0.0;
    *v1 = 0.0;
    *v2 = 0.0;
  }
}

void student_pass_primitive_j0(double v0, double a0, double sf, double vfmin,
                               double vfmax, double coefsj0[6])
{
  double T[2];
  double v1;
  int i;
  /*  */
  /*           Agent Logic */
  /*          Pass Primitive J0 */
  /*               2025 */
  /*  */
  final_opt_time_j0_pass(v0, a0, sf, T);
  /* FINAL_OPT_VEL_PASS */
  /*     FINAL_OPT_VEL_PASS_VAR = FINAL_OPT_VEL_PASS(V0,A0,SF,T) */
  /*     This function was generated by the Symbolic Math Toolbox version 24.1.
   */
  /*     02-Dec-2025 13:24:28 */
  v1 = ((sf * -15.0 + T[0] * v0 * 7.0) + T[0] * T[0] * a0) * -0.125 / T[0];
  if ((vfmin < v1) && (v1 < vfmax)) {
    coef_list(v0, a0, sf, v1, 0.0, T[0], coefsj0);
  } else {
    /* FINAL_OPT_VEL_PASS */
    /*     FINAL_OPT_VEL_PASS_VAR = FINAL_OPT_VEL_PASS(V0,A0,SF,T) */
    /*     This function was generated by the Symbolic Math Toolbox
     * version 24.1. */
    /*     02-Dec-2025 13:24:28 */
    v1 = ((sf * -15.0 + T[1] * v0 * 7.0) + T[1] * T[1] * a0) * -0.125 / T[1];
    if ((vfmin < v1) && (v1 < vfmax)) {
      coef_list(v0, a0, sf, v1, 0.0, T[1], coefsj0);
    } else {
      for (i = 0; i < 6; i++) {
        coefsj0[i] = 0.0;
      }
    }
  }
}

void student_stop_primitive(double v0, double a0, double sf, double coefs[6],
                            double *maxsf, double *tf)
{
  int i;
  /*  */
  /*           Agent Logic */
  /*          Stop Primitive */
  /*               2025 */
  /*  */
  /*    ... */
  if (v0 > 0.0) {
    double d;
    *maxsf = sf;
    d = 4.0 * (v0 * v0);
    if (d + 5.0 * a0 * sf < 0.0) {
      *maxsf = -(d / (5.0 * a0));
      *tf = 5.0 * *maxsf / v0;
    } else {
      *tf = final_opt_time_stop(v0, a0, sf);
    }
    coef_list(v0, a0, *maxsf, 0.0, 0.0, *tf, coefs);
  } else {
    *maxsf = 0.0;
    *tf = 0.0;
    for (i = 0; i < 6; i++) {
      coefs[i] = 0.0;
    }
  }
}

void student_stop_primitive_j0(double v0, double a0, double coefsj0[6],
                               double *sfj0, double *tfj0)
{
  int i;
  /*  */
  /*            Agent Logic */
  /*          Stop Primitive J0 */
  /*               2025 */
  /*  */
  if ((v0 > 0.0) && (a0 < 0.0)) {
    /* FINAL_OPT_TIME_STOP_J0 */
    /*     OUT1 = FINAL_OPT_TIME_STOP_J0(V0,A0) */
    /*     This function was generated by the Symbolic Math Toolbox
     * version 24.1. */
    /*     02-Dec-2025 13:33:20 */
    *tfj0 = v0 * -2.0 / a0;
    /*  0 because its the current time */
    *sfj0 = final_opt_pos_j0(v0, a0, 0.0, 0.0, 0.0, *tfj0);
    coef_list(v0, a0, *sfj0, 0.0, 0.0, *tfj0, coefsj0);
  } else {
    *tfj0 = 0.0;
    *sfj0 = 0.0;
    for (i = 0; i < 6; i++) {
      coefsj0[i] = 0.0;
    }
  }
}

double v_opt(double t, double v0, double a0, double sf, double vf, double af,
             double T)
{
  double b_out1_tmp;
  double out1_tmp;
  double t2;
  double t3;
  double t4;
  double t4_tmp;
  /* V_OPT */
  /*     OUT1 = V_OPT(t,V0,A0,SF,VF,AF,T) */
  /*     This function was generated by the Symbolic Math Toolbox version 24.1.
   */
  /*     02-Dec-2025 13:33:10 */
  t2 = T * T;
  t3 = af * t2;
  t4_tmp = a0 * t2;
  t4 = t4_tmp * 3.0;
  out1_tmp = T * v0;
  b_out1_tmp = T * vf;
  return (((v0 + a0 * t) -
           1.0 / rt_powd_snf(T, 5.0) * rt_powd_snf(t, 4.0) *
               ((((sf * -12.0 - t3) + out1_tmp * 6.0) + b_out1_tmp * 6.0) +
                t4_tmp) *
               2.5) -
          1.0 / rt_powd_snf(T, 3.0) * (t * t) *
              ((((sf * -20.0 + t4) - t3) + out1_tmp * 12.0) +
               b_out1_tmp * 8.0) *
              1.5) +
         rt_powd_snf(t, 3.0) / (t2 * t2) *
             ((((sf * -30.0 - t3 * 2.0) + t4) + out1_tmp * 16.0) +
              b_out1_tmp * 14.0) *
             2.0;
}

/* End of code generation (primitives.c) */
